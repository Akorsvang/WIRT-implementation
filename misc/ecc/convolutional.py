# -*- coding: utf-8 -*-

import numpy
import numpy as np

from misc.ecc.ecc_utils import channel

RATE = 1 / 2
MAX_DIST = int(1 / RATE)


def hamming_dist(val, poly):
    mask = val ^ poly
    dist = 0

    while(mask > 0):
        mask &= mask - 1
        dist += 1

    return dist
#    return bin(mask).count('1')


def gen_hamming_dist_arr(mem_order):
    possible_states = np.arange(2**mem_order, dtype=np.uint8)
    return np.unpackbits(possible_states).reshape(-1, 8).sum(axis=1)


def bit_parity(value):
    par = 0
    while value > 0:
        par = not par
        value &= (value - 1)

    return int(par)


def conv_encode(data, const_len, poly1, poly2):
    """ Rate 1/2 convolutional encoder """
    MEMORY_ORDER = const_len - 1
    CODE_LENGTH = 8 * len(data)

    bin_data = np.unpackbits(np.asarray(data, dtype=np.uint8))

    # Check if polynomials are out of range.
    MAX_POLY = (2**(const_len)) - 1
    poly1 = np.asarray(poly1, dtype=np.uint8)
    poly2 = np.asarray(poly2, dtype=np.uint8)
    if poly1 > MAX_POLY or poly2 > MAX_POLY:
        return -1

    # The polys (octal) are converted to a list of binary digits.
    first_poly_bin = np.unpackbits(poly1)[-(MEMORY_ORDER + 1):]
    second_poly_bin = np.unpackbits(poly2)[-(MEMORY_ORDER + 1):]
    poly_bin = np.vstack((first_poly_bin, second_poly_bin))

    parity = np.empty((CODE_LENGTH, 2), dtype=np.uint8)
    working_bits = np.zeros(MEMORY_ORDER + 1, dtype=np.uint8)

    for i in range(CODE_LENGTH):
        working_bits[1:] = working_bits[:-1]  # Shift the previous bits up
        working_bits[0] = bin_data[i]  # Put the new bit into the sequence

        parity[i] = (poly_bin * working_bits).sum(axis=1)

    parity = np.mod(parity, 2)

    return np.packbits(parity, axis=0)


def encode_numpy(data, const_len, poly1, poly2):
    MEMORY_ORDER = const_len - 1
    CODE_LENGTH = 8 * len(data)

    data_array = numpy.array(data, dtype=numpy.uint8)
    bin_data = numpy.unpackbits(data_array)

    # Check if polynomials are out of range.
    MAX_POLY = (2**(const_len)) - 1
    if poly1 > MAX_POLY or poly2 > MAX_POLY:
        return -1

    # The polys (octal) are converted to a list of binary digits.
    # This conversion method returns LSB first, so we flip it because we want MSB.
    first_poly_bin = [((poly1 >> i) & 1) for i in range(MEMORY_ORDER + 1)][::-1]
    second_poly_bin = [((poly2 >> i) & 1) for i in range(MEMORY_ORDER + 1)][::-1]

    parity = {}
    (parity[0], parity[1]) = ([], [])
    previous_data = [0] * MEMORY_ORDER

    for i in range(CODE_LENGTH):
        parity[0].append(first_poly_bin[0] * bin_data[i])
        parity[1].append(second_poly_bin[0] * bin_data[i])

        for j in range(MEMORY_ORDER):
            parity[0][i] += first_poly_bin[j + 1] * previous_data[j]
            parity[1][i] += second_poly_bin[j + 1] * previous_data[j]

        parity[0][i] = parity[0][i] % 2
        parity[1][i] = parity[1][i] % 2

        for k in range(MEMORY_ORDER - 1, 0, -1):
            previous_data[k] = previous_data[k - 1]

        previous_data[0] = bin_data[i]

    par0 = numpy.packbits(parity[0])
    par1 = numpy.packbits(parity[1])

    return numpy.concatenate((par0, par1))

# Takes two lists of parities and decodes to a single list of bits


def conv_decode(parity0, parity1, const_len, poly0, poly1):
    par0_array = numpy.unpackbits(numpy.array(parity0, dtype=numpy.uint8))
    par1_array = numpy.unpackbits(numpy.array(parity1, dtype=numpy.uint8))

    # While having the parity as two different list is pretty convenient many places
    # here we prefer it as a single list of [0, 1, 2, 3]
    full_parity = (par0_array << 1) ^ par1_array

    # The total number of states are 2^memory_order
    mem_order = const_len - 1
    states = np.arange(2**mem_order)
    hamming_dist_arr = gen_hamming_dist_arr(mem_order + 1)

    # All possible state changes are stored in this table.
    # For each state change a right shift marks the change in the memory registers
    # and the top-most bit marks the current input
    possible_next_states = []
    for state in states:
        option0 = state >> 1
        option1 = (state >> 1) + (2**mem_order) // 2
        possible_next_states.append([option0, option1])
    # print("PNS:",end="")
    # print(possible_next_states)

    # Now we calculate the poly it would generate when moving from a state (the index)
    # to either a 0 input or a 1 input. The polys are generated by and-ing the states
    # with the generator polys, and calculating the parities
    state_change_poly = []
    for state in states:
        state_change0 = state
        state_change1 = (1 << mem_order) ^ state
        par_bit0 = (bit_parity(state_change0 & poly0) << 1) + bit_parity(state_change0 & poly1)
        par_bit1 = (bit_parity(state_change1 & poly0) << 1) + bit_parity(state_change1 & poly1)

        state_change_poly.append([par_bit0, par_bit1])
    # print("SCP:", end="")
    # print(state_change_poly)

    # The first path metric cannot start in anything but the 0 state.
    # This is implemented as a unreasonable high cost for going from the other states
    path_metrics = []
    path_metrics.append([(10000, 0)] * 2**mem_order)
    path_metrics[0][0] = (0, 0)

    # bitnr is the transition from t_{bitnr-1} to t_{bitnr}
    # There are as many transitions as parity-pairs received
    # To calculate the path metrics, all the branch metrics are calculated
    # and the branch with the last weigth is chosen for each path.
    for bitnr in range(len(full_parity)):
        branch_metric = [[] for i in range(2**mem_order)]
        for cur_state in states:
            prev_pathmetric = path_metrics[bitnr][cur_state][0]
            cost_zerobit = hamming_dist(full_parity[bitnr], state_change_poly[cur_state][0])
            cost_onebit = MAX_DIST - cost_zerobit

            branch_metric[possible_next_states[cur_state][0]].append(
                ((cost_zerobit + prev_pathmetric), cur_state))

            branch_metric[possible_next_states[cur_state][1]].append(
                ((cost_onebit + prev_pathmetric), cur_state))

        path_metrics.append([min(path) for path in branch_metric])

    # print("Path metrics: ")
    # pprint(list(reversed(path_metrics)))

    # The best (most likely) solution, is to save the previous state leading up to
    # a given point. By doing this we can just look at the path metric of the last
    # value, and then walk the path taken to get that PM.
    path_metrics_rev = path_metrics[::-1]

    # We find the first point by taking the one with the lowest path count.
    point = path_metrics_rev[0].index(min(path_metrics_rev[0]))

    # For the rest of the points, we just look at the stored path
    (_, next_point) = min(path_metrics_rev[0])

    # We now walk through the states. If there's an upward transition from
    # point to next_point, we got a one, otherwise a 0
    # When states are the same as previously, we received a 1 if we're in the max state
    # and a 0 if we're in the min state
    bit_guess = []
    path = []
    for i in range(1, len(path_metrics_rev)):
        path.append(point)

        bit = int(point >= (2**(mem_order - 1)))
        bit_guess.append(bit)

        point = next_point
        (_, next_point) = path_metrics_rev[i][point]

    # We always end in state zero.
    path.append(0)

    output = numpy.packbits(bit_guess[::-1])
    return output


if __name__ == '__main__':
    N = 10000
    # dat = np.array([24, 35, 12, 25], dtype=np.uint8)
    dat = np.frombuffer(np.random.bytes(N), dtype=np.uint8)
    result = conv_encode(dat, 3, 7, 5)
    res2 = encode_numpy(dat, 3, 7, 5)

    print("Encode equal:", np.all(np.concatenate((result[:, 0], result[:, 1])) == res2))

    decoded_res = conv_decode(result[:, 0], result[:, 1], 3, 7, 5)
    print("Clean decode successful:", np.all(decoded_res == dat))

    BER = 0.01 / 2
    result_ch = (channel(result[:, 0], BER), channel(result[:, 1], BER))
    decoded_ch = conv_decode(result_ch[0][0], result_ch[1][0], 3, 7, 5)

    print("True BER: ", (np.unpackbits(result_ch[0][0]) != np.unpackbits(result[:, 0])).mean() + (np.unpackbits(result_ch[1][0]) != np.unpackbits(result[:, 1])).mean())
    print("BER after decode:", (np.unpackbits(decoded_ch) != np.unpackbits(dat)).mean())
